#!/usr/bin/env python

import argparse
import numpy as np

from tensorflow.keras import Model, losses
from keras.models import load_model
from root_gnn.utils import pad_input

# npz in, npz out, model in

parser = argparse.ArgumentParser(description='Predict with RNN')
parser.add_argument('model_path', default=None)
parser.add_argument('--input','-i',default=None)
parser.add_argument('--output','-o',default=None)
parser.add_argument('-l', default=1)
parser.add_argument('--pfn', action='store_true')
    
    
if __name__ == "__main__":
    args = parser.parse_args()
    data = np.load(args.input)
    class LogLoss(losses.BinaryCrossentropy):
        def __init__(self, real_global_weight=args.l, fake_global_weight=1, **kwargs):
            super(LogLoss, self).__init__(**kwargs)
            self.w_global_real = real_global_weight
            self.w_global_fake = fake_global_weight

        def __call__(self, y_true, y_pred, sample_weight=None):
            global_weights = y_true * self.w_global_real \
                + (1 - y_true) * self.w_global_fake
            return super(LogLoss, self).__call__(y_true, y_pred, sample_weight=global_weights)
    
    try:
        model=load_model(args.model_path)
    except:
        model=load_model(args.model_path, custom_objects={'LogLoss': LogLoss})
        # FIXME: pass in config without manually set the weights
    model.summary()

    
    len_data = len(data['track_info'])//500*500
    if args.pfn:
        predictions = model.predict(pad_input(data['track_info'][:len_data],data['cluster_info'][:len_data]), batch_size=500)[:,1]
    else:
        predictions = model.predict([data['track_info'][:len_data],data['cluster_info'][:len_data],data['hlv_info'][:len_data]], batch_size=500)
    
    truth_info = data['labels']
    np.savez(args.output,predictions=predictions,truth_info=truth_info)
